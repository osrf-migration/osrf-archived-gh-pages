{"rendered": {"reason": {"raw": "Revive after restructuring work. See issue #35", "markup": "markdown", "html": "<p>Revive after restructuring work. See issue #35</p>", "type": "rendered"}, "description": {"raw": "@nkoenig mentioned something like this idea in the gazebo meeting today. I think it was the idea of returning a per-component handle instead of a reference to the component. This PR adds one handle for accessing all entities and components. The components are accessed by reference, but they're guaranteed to be valid while the handle is alive. It depends on pull request #36 and pull request #37.\r\n\r\nBefore some code accesses entities/components it must get a handle by calling `manager.Handle()`. As long as this handle is alive the entities/components won't be updated by the database. This means they're safe to access/modify from other threads.\r\n\r\nFor example, say a GUI plugin needs to move an entity and it has a pointer to the manager. The GUI plugin would get a handle from the manager, modify the pose component on the entity to move, then let the handle go out of scope.\r\n\r\nThis PR adds `Manager::Handle()` which returns an `std::unique_ptr<DataHandle>`. These methods used to be on `Manager` but are now on `DataHandle`: `CreateEntity()`, `DeleteEntity()`, `SimulationTime()`, `SimulationTime(_newTime)`, `Entity()`. The database has a new method `BlockUpdate(bool _doBlock)`. It maintains a count of how many handles are blocking the update. `DataHandle` calls this method in it's constructor to block the update, and again in it's destructor to stop blocking the update.", "markup": "markdown", "html": "<p>@nkoenig mentioned something like this idea in the gazebo meeting today. I think it was the idea of returning a per-component handle instead of a reference to the component. This PR adds one handle for accessing all entities and components. The components are accessed by reference, but they're guaranteed to be valid while the handle is alive. It depends on <a href=\"#!/osrf/gazebo_experimental/pull-requests/36/components-defined-by-protobuf-files\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #36</a> and <a href=\"#!/osrf/gazebo_experimental/pull-requests/37/wip-components-pimpl-integration\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #37</a>.</p>\n<p>Before some code accesses entities/components it must get a handle by calling <code>manager.Handle()</code>. As long as this handle is alive the entities/components won't be updated by the database. This means they're safe to access/modify from other threads.</p>\n<p>For example, say a GUI plugin needs to move an entity and it has a pointer to the manager. The GUI plugin would get a handle from the manager, modify the pose component on the entity to move, then let the handle go out of scope.</p>\n<p>This PR adds <code>Manager::Handle()</code> which returns an <code>std::unique_ptr&lt;DataHandle&gt;</code>. These methods used to be on <code>Manager</code> but are now on <code>DataHandle</code>: <code>CreateEntity()</code>, <code>DeleteEntity()</code>, <code>SimulationTime()</code>, <code>SimulationTime(_newTime)</code>, <code>Entity()</code>. The database has a new method <code>BlockUpdate(bool _doBlock)</code>. It maintains a count of how many handles are blocking the update. <code>DataHandle</code> calls this method in it's constructor to block the update, and again in it's destructor to stop blocking the update.</p>", "type": "rendered"}, "title": {"raw": "Manager handle to access entities and components", "markup": "markdown", "html": "<p>Manager handle to access entities and components</p>", "type": "rendered"}}, "type": "pullrequest", "description": "@nkoenig mentioned something like this idea in the gazebo meeting today. I think it was the idea of returning a per-component handle instead of a reference to the component. This PR adds one handle for accessing all entities and components. The components are accessed by reference, but they're guaranteed to be valid while the handle is alive. It depends on pull request #36 and pull request #37.\r\n\r\nBefore some code accesses entities/components it must get a handle by calling `manager.Handle()`. As long as this handle is alive the entities/components won't be updated by the database. This means they're safe to access/modify from other threads.\r\n\r\nFor example, say a GUI plugin needs to move an entity and it has a pointer to the manager. The GUI plugin would get a handle from the manager, modify the pose component on the entity to move, then let the handle go out of scope.\r\n\r\nThis PR adds `Manager::Handle()` which returns an `std::unique_ptr<DataHandle>`. These methods used to be on `Manager` but are now on `DataHandle`: `CreateEntity()`, `DeleteEntity()`, `SimulationTime()`, `SimulationTime(_newTime)`, `Entity()`. The database has a new method `BlockUpdate(bool _doBlock)`. It maintains a count of how many handles are blocking the update. `DataHandle` calls this method in it's constructor to block the update, and again in it's destructor to stop blocking the update.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/pullrequests/43/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/diffstat/osrf/gazebo_experimental:f26ae9ab19ae%0D786402f94128?from_pullrequest_id=43"}, "commits": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/43/commits.json"}, "self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/43.json"}, "comments": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/43/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/pullrequests/43/merge"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/43"}, "activity": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/43/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/diff/osrf/gazebo_experimental:f26ae9ab19ae%0D786402f94128?from_pullrequest_id=43"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/pullrequests/43/approve"}, "statuses": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/43/statuses_page=1.json"}}, "title": "Manager handle to access entities and components", "close_source_branch": false, "reviewers": [], "id": 43, "destination": {"commit": {"hash": "786402f94128", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/786402f94128.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/786402f94128"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl_integration"}}, "created_on": "2017-07-07T01:48:53.929928+00:00", "summary": {"raw": "@nkoenig mentioned something like this idea in the gazebo meeting today. I think it was the idea of returning a per-component handle instead of a reference to the component. This PR adds one handle for accessing all entities and components. The components are accessed by reference, but they're guaranteed to be valid while the handle is alive. It depends on pull request #36 and pull request #37.\r\n\r\nBefore some code accesses entities/components it must get a handle by calling `manager.Handle()`. As long as this handle is alive the entities/components won't be updated by the database. This means they're safe to access/modify from other threads.\r\n\r\nFor example, say a GUI plugin needs to move an entity and it has a pointer to the manager. The GUI plugin would get a handle from the manager, modify the pose component on the entity to move, then let the handle go out of scope.\r\n\r\nThis PR adds `Manager::Handle()` which returns an `std::unique_ptr<DataHandle>`. These methods used to be on `Manager` but are now on `DataHandle`: `CreateEntity()`, `DeleteEntity()`, `SimulationTime()`, `SimulationTime(_newTime)`, `Entity()`. The database has a new method `BlockUpdate(bool _doBlock)`. It maintains a count of how many handles are blocking the update. `DataHandle` calls this method in it's constructor to block the update, and again in it's destructor to stop blocking the update.", "markup": "markdown", "html": "<p>@nkoenig mentioned something like this idea in the gazebo meeting today. I think it was the idea of returning a per-component handle instead of a reference to the component. This PR adds one handle for accessing all entities and components. The components are accessed by reference, but they're guaranteed to be valid while the handle is alive. It depends on <a href=\"#!/osrf/gazebo_experimental/pull-requests/36/components-defined-by-protobuf-files\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #36</a> and <a href=\"#!/osrf/gazebo_experimental/pull-requests/37/wip-components-pimpl-integration\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #37</a>.</p>\n<p>Before some code accesses entities/components it must get a handle by calling <code>manager.Handle()</code>. As long as this handle is alive the entities/components won't be updated by the database. This means they're safe to access/modify from other threads.</p>\n<p>For example, say a GUI plugin needs to move an entity and it has a pointer to the manager. The GUI plugin would get a handle from the manager, modify the pose component on the entity to move, then let the handle go out of scope.</p>\n<p>This PR adds <code>Manager::Handle()</code> which returns an <code>std::unique_ptr&lt;DataHandle&gt;</code>. These methods used to be on <code>Manager</code> but are now on <code>DataHandle</code>: <code>CreateEntity()</code>, <code>DeleteEntity()</code>, <code>SimulationTime()</code>, <code>SimulationTime(_newTime)</code>, <code>Entity()</code>. The database has a new method <code>BlockUpdate(bool _doBlock)</code>. It maintains a count of how many handles are blocking the update. <code>DataHandle</code> calls this method in it's constructor to block the update, and again in it's destructor to stop blocking the update.</p>", "type": "rendered"}, "source": {"commit": {"hash": "f26ae9ab19ae", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/f26ae9ab19ae.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/f26ae9ab19ae"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "manager_handle"}}, "comment_count": 0, "state": "DECLINED", "task_count": 0, "participants": [], "reason": "Revive after restructuring work. See issue #35", "updated_on": "2017-08-14T15:11:38.016977+00:00", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "merge_commit": null, "closed_by": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}