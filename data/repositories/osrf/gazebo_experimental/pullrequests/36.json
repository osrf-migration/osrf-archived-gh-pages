{"rendered": {"reason": {"raw": "Will be replaced by changes on nate_tweaks", "markup": "markdown", "html": "<p>Will be replaced by changes on nate_tweaks</p>", "type": "rendered"}, "description": {"raw": "**Update** components have been simplified to solve a liking issue. I also fixed likely visibility issues with components on windows after reading  PRs/issues by @traversaro [here](https://bitbucket.org/osrf/gazebo/pull-requests/2738).\r\n\r\nThis feature is split into two pull requests. This pull request is the code to generate c++ code from protobuf files using a protobuf compiler plugin. The integration of this with the rest of the code is in pull request #37.\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* ~~Component data can be stored adjacent in memory~~\r\n    * **Update** Components are now normal PIMPL classes. I dropped this optimization in favor of working code now.\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\nauto *comp = someEntity.ComponentMutable<gazebo::components::MyPoseComponent>();\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp->Pose().Pos().X() = 5;\r\ncomp->Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp->ParentFrame() = \"my_frame\";\r\nstd::cout << comp->ParentFrame(); // \"my_frame\"\r\n```\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png~~\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* ~~Pose.factory.hh~~\r\n    * ~~Has a factory class with methods for constructing/destructing API and Storage classes~~\r\n    * **Update** Removed factory, component itself is now a plugin\r\n* ~~Pose.factory.cc~~\r\n    * ~~Registers plugin of type gazebo::ecs::ComponentFactory~~\r\n    * **Update** Removed\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png~~\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of ~~ComponentFactory~~ `Component`, which has methods that allow `gazebo::ecs::EntityComponentDatabase` to store the component without knowing it's type.\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png~~\r\n\r\n**Update**  Components are a normal PIMPL class. The optimization of allowing the private implementations to be constructed adjacent to each other was removed because it is tricky to make component libraries depend on each other properly. Also I missed something important: alignment.\r\n~~Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.~~", "markup": "markdown", "html": "<p><strong>Update</strong> components have been simplified to solve a liking issue. I also fixed likely visibility issues with components on windows after reading  PRs/issues by @traversaro <a data-is-external-link=\"true\" href=\"https://bitbucket.org/osrf/gazebo/pull-requests/2738\" rel=\"nofollow\">here</a>.</p>\n<p>This feature is split into two pull requests. This pull request is the code to generate c++ code from protobuf files using a protobuf compiler plugin. The integration of this with the rest of the code is in <a href=\"#!/osrf/gazebo_experimental/pull-requests/37/wip-components-pimpl-integration\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #37</a>.</p>\n<p>This is a redesign of components. The goal for this pull request is to offer these benefits</p>\n<ul>\n<li>No use of RTTI <a href=\"#!/osrf/gazebo_experimental/issues/29/determine-if-typeid-works-accross-dll\" rel=\"nofollow\" title=\"Determine if typeid works accross DLL boundaries on windows\" class=\"ap-connect-link\">#29</a></li>\n<li>Components use PIMPL <a href=\"#!/osrf/gazebo_experimental/issues/25/components-should-use-pimpl-pattern-to\" rel=\"nofollow\" title=\"Components should use PIMPL pattern to avoid ABI breakage during updates\" class=\"ap-connect-link\">#25</a></li>\n</ul>\n<p>Without losing these benefits:</p>\n<ul>\n<li>New components come from plugins without recompiling the database</li>\n<li><del>Component data can be stored adjacent in memory</del><ul>\n<li><strong>Update</strong> Components are now normal PIMPL classes. I dropped this optimization in favor of working code now.</li>\n</ul>\n</li>\n<li>Components have convenient <code>ignition::math</code> types</li>\n</ul>\n<p>And with a path towards these features in the future:</p>\n<ul>\n<li>Components are serializable<ul>\n<li>Create a component viewer <a href=\"#!/osrf/gazebo_experimental/issues/19/create-viewer-for-viewing-all-entities-and\" rel=\"nofollow\" title=\"Create viewer for viewing all entities and components\" class=\"ap-connect-link\">#19</a></li>\n<li>Run ECS on different systems #18 </li>\n</ul>\n</li>\n</ul>\n<p>A protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.</p>\n<p>For example this protobuf message</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">syntax</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;proto2&quot;</span><span class=\"p\">;</span>\n\n<span class=\"n\">package</span> <span class=\"n\">gazebo</span><span class=\"o\">.</span><span class=\"n\">components</span><span class=\"p\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"s2\">&quot;gazebo/components/Pose3d.proto&quot;</span><span class=\"p\">;</span>\n\n<span class=\"n\">message</span> <span class=\"n\">MyPoseComponent</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">optional</span> <span class=\"n\">string</span> <span class=\"n\">ParentFrame</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"n\">optional</span> <span class=\"n\">Pose3d</span> <span class=\"n\">Pose</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Would be used like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// Component API files end in &quot;.api.hh&quot;</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&quot;gazebo/components/MyPoseComponent.api.hh&quot;</span><span class=\"cp\"></span>\n<span class=\"c1\">// ...</span>\n<span class=\"c1\">// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database</span>\n<span class=\"k\">auto</span> <span class=\"o\">*</span><span class=\"n\">comp</span> <span class=\"o\">=</span> <span class=\"n\">someEntity</span><span class=\"p\">.</span><span class=\"n\">ComponentMutable</span><span class=\"o\">&lt;</span><span class=\"n\">gazebo</span><span class=\"o\">::</span><span class=\"n\">components</span><span class=\"o\">::</span><span class=\"n\">MyPoseComponent</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type</span>\n<span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">Pose</span><span class=\"p\">().</span><span class=\"n\">Pos</span><span class=\"p\">().</span><span class=\"n\">X</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">Pose</span><span class=\"p\">().</span><span class=\"n\">Rot</span><span class=\"p\">().</span><span class=\"n\">W</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"mf\">1.0f</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// ParentFrame string became a method that returns a reference</span>\n<span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">ParentFrame</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"s\">&quot;my_frame&quot;</span><span class=\"p\">;</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">ParentFrame</span><span class=\"p\">();</span> <span class=\"c1\">// &quot;my_frame&quot;</span>\n</pre></div>\n\n\n<p>Notes/Limitations on generation from protobuf files:</p>\n<ul>\n<li>must have exactly one top-level message per proto file</li>\n<li>can import other proto files as long as they have exactly one top-level message</li>\n<li>can use enumerations as long as they're nested in a message</li>\n<li>Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API</li>\n</ul>\n<p>To-do in the future</p>\n<ul>\n<li>Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)</li>\n<li>Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)</li>\n</ul>\n<h2 id=\"markdown-header-generated-code\">Generated Code</h2>\n<p><del><a href=\"data/bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png</a></del></p>\n<p>Given a protobuf file called <code>Pose.proto</code>, the protoc plugin will generate these files:</p>\n<ul>\n<li><code>Pose.api.hh</code><ul>\n<li>Has Api class called <code>Pose</code> using PIMPL pattern</li>\n<li>Api class inherits from <code>gazebo::ecs::ComponentAPI</code></li>\n<li>This is the only header file that gets installed</li>\n</ul>\n</li>\n<li><code>Pose.api.cc</code><ul>\n<li>Definitions for generated API class</li>\n</ul>\n</li>\n<li><code>Pose.storage.hh</code><ul>\n<li>Has storage class called <code>PoseStorage</code></li>\n</ul>\n</li>\n<li><del>Pose.factory.hh</del><ul>\n<li><del>Has a factory class with methods for constructing/destructing API and Storage classes</del></li>\n<li><strong>Update</strong> Removed factory, component itself is now a plugin</li>\n</ul>\n</li>\n<li><del>Pose.factory.cc</del><ul>\n<li><del>Registers plugin of type gazebo::ecs::ComponentFactory</del></li>\n<li><strong>Update</strong> Removed</li>\n</ul>\n</li>\n</ul>\n<p><del><a href=\"data/bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png</a></del></p>\n<p>The generated files get built into a single plugin library called <code>libGazeboComponentPose.so</code>. Loading this library gives an instance of <del>ComponentFactory</del> <code>Component</code>, which has methods that allow <code>gazebo::ecs::EntityComponentDatabase</code> to store the component without knowing it's type.</p>\n<p><del><a href=\"data/bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png</a></del></p>\n<p><strong>Update</strong>  Components are a normal PIMPL class. The optimization of allowing the private implementations to be constructed adjacent to each other was removed because it is tricky to make component libraries depend on each other properly. Also I missed something important: alignment.\n<del>Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.</del></p>", "type": "rendered"}, "title": {"raw": "Components defined by protobuf files", "markup": "markdown", "html": "<p>Components defined by protobuf files</p>", "type": "rendered"}}, "type": "pullrequest", "description": "**Update** components have been simplified to solve a liking issue. I also fixed likely visibility issues with components on windows after reading  PRs/issues by @traversaro [here](https://bitbucket.org/osrf/gazebo/pull-requests/2738).\r\n\r\nThis feature is split into two pull requests. This pull request is the code to generate c++ code from protobuf files using a protobuf compiler plugin. The integration of this with the rest of the code is in pull request #37.\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* ~~Component data can be stored adjacent in memory~~\r\n    * **Update** Components are now normal PIMPL classes. I dropped this optimization in favor of working code now.\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\nauto *comp = someEntity.ComponentMutable<gazebo::components::MyPoseComponent>();\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp->Pose().Pos().X() = 5;\r\ncomp->Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp->ParentFrame() = \"my_frame\";\r\nstd::cout << comp->ParentFrame(); // \"my_frame\"\r\n```\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png~~\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* ~~Pose.factory.hh~~\r\n    * ~~Has a factory class with methods for constructing/destructing API and Storage classes~~\r\n    * **Update** Removed factory, component itself is now a plugin\r\n* ~~Pose.factory.cc~~\r\n    * ~~Registers plugin of type gazebo::ecs::ComponentFactory~~\r\n    * **Update** Removed\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png~~\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of ~~ComponentFactory~~ `Component`, which has methods that allow `gazebo::ecs::EntityComponentDatabase` to store the component without knowing it's type.\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png~~\r\n\r\n**Update**  Components are a normal PIMPL class. The optimization of allowing the private implementations to be constructed adjacent to each other was removed because it is tricky to make component libraries depend on each other properly. Also I missed something important: alignment.\r\n~~Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.~~", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/pullrequests/36/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/diffstat/osrf/gazebo_experimental:76cc5fad2e63%0D458110f786c9?from_pullrequest_id=36"}, "commits": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/commits.json"}, "self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "comments": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/pullrequests/36/merge"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}, "activity": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/diff/osrf/gazebo_experimental:76cc5fad2e63%0D458110f786c9?from_pullrequest_id=36"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/pullrequests/36/approve"}, "statuses": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/statuses_page=1.json"}}, "title": "Components defined by protobuf files", "close_source_branch": false, "reviewers": [], "id": 36, "destination": {"commit": {"hash": "458110f786c9", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/458110f786c9.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/458110f786c9"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "created_on": "2017-06-10T00:11:40.836385+00:00", "summary": {"raw": "**Update** components have been simplified to solve a liking issue. I also fixed likely visibility issues with components on windows after reading  PRs/issues by @traversaro [here](https://bitbucket.org/osrf/gazebo/pull-requests/2738).\r\n\r\nThis feature is split into two pull requests. This pull request is the code to generate c++ code from protobuf files using a protobuf compiler plugin. The integration of this with the rest of the code is in pull request #37.\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* ~~Component data can be stored adjacent in memory~~\r\n    * **Update** Components are now normal PIMPL classes. I dropped this optimization in favor of working code now.\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\nauto *comp = someEntity.ComponentMutable<gazebo::components::MyPoseComponent>();\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp->Pose().Pos().X() = 5;\r\ncomp->Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp->ParentFrame() = \"my_frame\";\r\nstd::cout << comp->ParentFrame(); // \"my_frame\"\r\n```\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png~~\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* ~~Pose.factory.hh~~\r\n    * ~~Has a factory class with methods for constructing/destructing API and Storage classes~~\r\n    * **Update** Removed factory, component itself is now a plugin\r\n* ~~Pose.factory.cc~~\r\n    * ~~Registers plugin of type gazebo::ecs::ComponentFactory~~\r\n    * **Update** Removed\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png~~\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of ~~ComponentFactory~~ `Component`, which has methods that allow `gazebo::ecs::EntityComponentDatabase` to store the component without knowing it's type.\r\n\r\n~~https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png~~\r\n\r\n**Update**  Components are a normal PIMPL class. The optimization of allowing the private implementations to be constructed adjacent to each other was removed because it is tricky to make component libraries depend on each other properly. Also I missed something important: alignment.\r\n~~Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.~~", "markup": "markdown", "html": "<p><strong>Update</strong> components have been simplified to solve a liking issue. I also fixed likely visibility issues with components on windows after reading  PRs/issues by @traversaro <a data-is-external-link=\"true\" href=\"https://bitbucket.org/osrf/gazebo/pull-requests/2738\" rel=\"nofollow\">here</a>.</p>\n<p>This feature is split into two pull requests. This pull request is the code to generate c++ code from protobuf files using a protobuf compiler plugin. The integration of this with the rest of the code is in <a href=\"#!/osrf/gazebo_experimental/pull-requests/37/wip-components-pimpl-integration\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #37</a>.</p>\n<p>This is a redesign of components. The goal for this pull request is to offer these benefits</p>\n<ul>\n<li>No use of RTTI <a href=\"#!/osrf/gazebo_experimental/issues/29/determine-if-typeid-works-accross-dll\" rel=\"nofollow\" title=\"Determine if typeid works accross DLL boundaries on windows\" class=\"ap-connect-link\">#29</a></li>\n<li>Components use PIMPL <a href=\"#!/osrf/gazebo_experimental/issues/25/components-should-use-pimpl-pattern-to\" rel=\"nofollow\" title=\"Components should use PIMPL pattern to avoid ABI breakage during updates\" class=\"ap-connect-link\">#25</a></li>\n</ul>\n<p>Without losing these benefits:</p>\n<ul>\n<li>New components come from plugins without recompiling the database</li>\n<li><del>Component data can be stored adjacent in memory</del><ul>\n<li><strong>Update</strong> Components are now normal PIMPL classes. I dropped this optimization in favor of working code now.</li>\n</ul>\n</li>\n<li>Components have convenient <code>ignition::math</code> types</li>\n</ul>\n<p>And with a path towards these features in the future:</p>\n<ul>\n<li>Components are serializable<ul>\n<li>Create a component viewer <a href=\"#!/osrf/gazebo_experimental/issues/19/create-viewer-for-viewing-all-entities-and\" rel=\"nofollow\" title=\"Create viewer for viewing all entities and components\" class=\"ap-connect-link\">#19</a></li>\n<li>Run ECS on different systems #18 </li>\n</ul>\n</li>\n</ul>\n<p>A protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.</p>\n<p>For example this protobuf message</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">syntax</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;proto2&quot;</span><span class=\"p\">;</span>\n\n<span class=\"n\">package</span> <span class=\"n\">gazebo</span><span class=\"o\">.</span><span class=\"n\">components</span><span class=\"p\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"s2\">&quot;gazebo/components/Pose3d.proto&quot;</span><span class=\"p\">;</span>\n\n<span class=\"n\">message</span> <span class=\"n\">MyPoseComponent</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">optional</span> <span class=\"n\">string</span> <span class=\"n\">ParentFrame</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"n\">optional</span> <span class=\"n\">Pose3d</span> <span class=\"n\">Pose</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Would be used like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// Component API files end in &quot;.api.hh&quot;</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&quot;gazebo/components/MyPoseComponent.api.hh&quot;</span><span class=\"cp\"></span>\n<span class=\"c1\">// ...</span>\n<span class=\"c1\">// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database</span>\n<span class=\"k\">auto</span> <span class=\"o\">*</span><span class=\"n\">comp</span> <span class=\"o\">=</span> <span class=\"n\">someEntity</span><span class=\"p\">.</span><span class=\"n\">ComponentMutable</span><span class=\"o\">&lt;</span><span class=\"n\">gazebo</span><span class=\"o\">::</span><span class=\"n\">components</span><span class=\"o\">::</span><span class=\"n\">MyPoseComponent</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type</span>\n<span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">Pose</span><span class=\"p\">().</span><span class=\"n\">Pos</span><span class=\"p\">().</span><span class=\"n\">X</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">Pose</span><span class=\"p\">().</span><span class=\"n\">Rot</span><span class=\"p\">().</span><span class=\"n\">W</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"mf\">1.0f</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// ParentFrame string became a method that returns a reference</span>\n<span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">ParentFrame</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"s\">&quot;my_frame&quot;</span><span class=\"p\">;</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">comp</span><span class=\"o\">-&gt;</span><span class=\"n\">ParentFrame</span><span class=\"p\">();</span> <span class=\"c1\">// &quot;my_frame&quot;</span>\n</pre></div>\n\n\n<p>Notes/Limitations on generation from protobuf files:</p>\n<ul>\n<li>must have exactly one top-level message per proto file</li>\n<li>can import other proto files as long as they have exactly one top-level message</li>\n<li>can use enumerations as long as they're nested in a message</li>\n<li>Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API</li>\n</ul>\n<p>To-do in the future</p>\n<ul>\n<li>Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)</li>\n<li>Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)</li>\n</ul>\n<h2 id=\"markdown-header-generated-code\">Generated Code</h2>\n<p><del><a href=\"data/bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png</a></del></p>\n<p>Given a protobuf file called <code>Pose.proto</code>, the protoc plugin will generate these files:</p>\n<ul>\n<li><code>Pose.api.hh</code><ul>\n<li>Has Api class called <code>Pose</code> using PIMPL pattern</li>\n<li>Api class inherits from <code>gazebo::ecs::ComponentAPI</code></li>\n<li>This is the only header file that gets installed</li>\n</ul>\n</li>\n<li><code>Pose.api.cc</code><ul>\n<li>Definitions for generated API class</li>\n</ul>\n</li>\n<li><code>Pose.storage.hh</code><ul>\n<li>Has storage class called <code>PoseStorage</code></li>\n</ul>\n</li>\n<li><del>Pose.factory.hh</del><ul>\n<li><del>Has a factory class with methods for constructing/destructing API and Storage classes</del></li>\n<li><strong>Update</strong> Removed factory, component itself is now a plugin</li>\n</ul>\n</li>\n<li><del>Pose.factory.cc</del><ul>\n<li><del>Registers plugin of type gazebo::ecs::ComponentFactory</del></li>\n<li><strong>Update</strong> Removed</li>\n</ul>\n</li>\n</ul>\n<p><del><a href=\"data/bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png</a></del></p>\n<p>The generated files get built into a single plugin library called <code>libGazeboComponentPose.so</code>. Loading this library gives an instance of <del>ComponentFactory</del> <code>Component</code>, which has methods that allow <code>gazebo::ecs::EntityComponentDatabase</code> to store the component without knowing it's type.</p>\n<p><del><a href=\"data/bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png</a></del></p>\n<p><strong>Update</strong>  Components are a normal PIMPL class. The optimization of allowing the private implementations to be constructed adjacent to each other was removed because it is tricky to make component libraries depend on each other properly. Also I missed something important: alignment.\n<del>Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.</del></p>", "type": "rendered"}, "source": {"commit": {"hash": "76cc5fad2e63", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/76cc5fad2e63.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/76cc5fad2e63"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "comment_count": 38, "state": "DECLINED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2017-07-19T19:03:17.427565+00:00", "type": "participant", "approved": false, "user": {"display_name": "Jose Luis Rivero", "uuid": "{d12309b2-f745-42ee-b119-aec4fcdf81fe}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bd12309b2-f745-42ee-b119-aec4fcdf81fe%7D"}, "html": {"href": "https://bitbucket.org/%7Bd12309b2-f745-42ee-b119-aec4fcdf81fe%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/109284c8b83411dbc7492138f6167e9ed=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJR-5.png"}}, "nickname": "Jose Luis Rivero", "type": "user", "account_id": "557058:155a32e2-420c-4d50-98e0-0e722f63f906"}}, {"role": "PARTICIPANT", "participated_on": "2017-07-27T15:33:54.133081+00:00", "type": "participant", "approved": false, "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}}, {"role": "PARTICIPANT", "participated_on": "2017-07-17T20:10:23.088777+00:00", "type": "participant", "approved": false, "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}}, {"role": "PARTICIPANT", "participated_on": "2017-07-19T21:24:44.864437+00:00", "type": "participant", "approved": false, "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}}, {"role": "PARTICIPANT", "participated_on": "2017-07-27T17:37:57.551343+00:00", "type": "participant", "approved": false, "user": {"display_name": "Ian Chen", "uuid": "{eaa6fca5-6deb-43f6-907f-971c144735dd}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D"}, "html": {"href": "https://bitbucket.org/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5/1e4adcdf-1946-4280-9aea-eb5f15a7f912/128"}}, "nickname": "Ian Chen", "type": "user", "account_id": "557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5"}}], "reason": "Will be replaced by changes on nate_tweaks", "updated_on": "2017-08-01T20:35:58.018368+00:00", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "merge_commit": null, "closed_by": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}}