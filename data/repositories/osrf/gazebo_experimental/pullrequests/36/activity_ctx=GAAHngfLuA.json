{"pagelen": 50, "values": [{"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nI decided to generate code from protobuf files because I wrote one component by hand and decided it was tedious/error-prone to write the code needed to achieve the above goals. Generating from protobuf has an added benefit of making it very easy to create new component types.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "21e4bdd778fe", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/21e4bdd778fe.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/21e4bdd778fe"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-12T22:55:38.932083+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nI decided to generate code from protobuf files because I wrote one component by hand and decided it was tedious/error-prone to write the code needed to achieve the above goals. Generating from protobuf has an added benefit of making it very easy to create new component types.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **repeated** and turn them into vectors\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* Update all entity and database APIs to use this new style of components\r\n* Document the design on this PR\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "21e4bdd778fe", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/21e4bdd778fe.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/21e4bdd778fe"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-12T17:32:01.538329+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nI decided to generate code from protobuf files because I wrote one component by hand and decided it was tedious/error-prone to write the code needed to achieve the above goals. Generating from protobuf has an added benefit of making it very easy to create new component types.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **repeated** and turn them into vectors\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* Update all entity and database APIs to use this new style of components\r\n* Document the design on this PR\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "bd2962b45b60", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/bd2962b45b60.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/bd2962b45b60"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-12T14:24:03.832647+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nI decided to generate code from protobuf files because I wrote one component by hand and decided it was tedious/error-prone to write the code needed to achieve the above goals. Generating from protobuf has an added benefit of making it very easy to create new component types.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* Update all entity and database APIs to use this new style of components\r\n* Document the design on this PR\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "bd2962b45b60", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/bd2962b45b60.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/bd2962b45b60"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-10T00:11:40.906847+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nI decided to generate code from protobuf files because I wrote one component by hand and decided it was tedious/error-prone to write the code needed to achieve the above goals. Generating from protobuf has an added benefit of making it very easy to create new component types.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* Update all entity and database APIs to use this new style of components\r\n* Document the design on this PR\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "bd2962b45b60", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/bd2962b45b60.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/bd2962b45b60"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-10T00:11:40.874939+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}]}