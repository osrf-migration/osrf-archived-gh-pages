{"pagelen": 50, "values": [{"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40164577.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40164577"}}, "parent": {"id": 40164268, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40164268.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40164268"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "The logic for loading libraries is a bit weak, it needs to be run from the directory it's loaded in. I'm surprised it isn't running with `make test`.", "markup": "markdown", "html": "<p>The logic for loading libraries is a bit weak, it needs to be run from the directory it's loaded in. I'm surprised it isn't running with <code>make test</code>.</p>", "type": "rendered"}, "created_on": "2017-07-05T18:24:46.040863+00:00", "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "inline": {}, "updated_on": "2017-07-05T18:26:09.481535+00:00", "type": "pullrequest_comment", "id": 40164577}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40164268.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40164268"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "\n~~This test is not run when I do `make test` and when I do `./test/protoc_tests/UNIT_pimpl-cpp_TEST` I get this error:~~\n\n`./test/protoc_tests/UNIT_pimpl-cpp_TEST: symbol lookup error: /home/louise/code/gazebo_experimental/build/test/protoc_tests/libgazeboComponentSubstitutedTypes.so: undefined symbol: _ZTIN6gazebo3ecs12ComponentAPIE`\n", "markup": "markdown", "html": "<p><del>This test is not run when I do <code>make test</code> and when I do <code>./test/protoc_tests/UNIT_pimpl-cpp_TEST</code> I get this error:</del></p>\n<p><code>./test/protoc_tests/UNIT_pimpl-cpp_TEST: symbol lookup error: /home/louise/code/gazebo_experimental/build/test/protoc_tests/libgazeboComponentSubstitutedTypes.so: undefined symbol: _ZTIN6gazebo3ecs12ComponentAPIE</code></p>", "type": "rendered"}, "created_on": "2017-07-05T18:20:48.484346+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "inline": {}, "updated_on": "2017-07-05T18:24:52.002141+00:00", "type": "pullrequest_comment", "id": 40164268}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40164548.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40164548"}}, "parent": {"id": 40164268, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40164268.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40164268"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "All lies, sorry about the noise, it was a local problem.\n\nBut now the test passes when I run `make test`, but all cases fail when I run just this test. I might still have local issues.", "markup": "markdown", "html": "<p>All lies, sorry about the noise, it was a local problem.</p>\n<p>But now the test passes when I run <code>make test</code>, but all cases fail when I run just this test. I might still have local issues.</p>", "type": "rendered"}, "created_on": "2017-07-05T18:24:16.725278+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "inline": {}, "updated_on": "2017-07-05T18:24:16.728010+00:00", "type": "pullrequest_comment", "id": 40164548}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components defined by protobuf files", "destination": {"commit": {"hash": "b21fecf94022", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b21fecf94022.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b21fecf94022"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "82d26d72b5e3", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/82d26d72b5e3.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/82d26d72b5e3"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-07-05T15:47:38.991078+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40023209.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40023209"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "Added dependency: `sudo apt install python-protobuf`", "markup": "markdown", "html": "<p>Added dependency: <code>sudo apt install python-protobuf</code></p>", "type": "rendered"}, "created_on": "2017-07-04T00:55:02.982887+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "updated_on": "2017-07-04T00:55:02.985279+00:00", "type": "pullrequest_comment", "id": 40023209}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40023125.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40023125"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "These could be taken from the object above, so we reduce the chance of someone forgetting to add the same type on both places.", "markup": "markdown", "html": "<p>These could be taken from the object above, so we reduce the chance of someone forgetting to add the same type on both places.</p>", "type": "rendered"}, "created_on": "2017-07-04T00:49:51.656380+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "inline": {}, "updated_on": "2017-07-04T00:49:51.658586+00:00", "type": "pullrequest_comment", "id": 40023125}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40022995.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40022995"}}, "parent": {"id": 40018650, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40018650.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40018650"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "Could you clarify a bit more? The API will include math types, right? For these ign-msgs will be used. Could you give an example of a component which wouldn't use ign-msgs?\n\nI might be missing the point, but I think it's interesting to have a common set of messages/components which is shared among all ignition libraries and Gazebo. ", "markup": "markdown", "html": "<p>Could you clarify a bit more? The API will include math types, right? For these ign-msgs will be used. Could you give an example of a component which wouldn't use ign-msgs?</p>\n<p>I might be missing the point, but I think it's interesting to have a common set of messages/components which is shared among all ignition libraries and Gazebo. </p>", "type": "rendered"}, "created_on": "2017-07-04T00:43:25.966902+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "inline": {}, "updated_on": "2017-07-04T00:43:25.969284+00:00", "type": "pullrequest_comment", "id": 40022995}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40018650.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40018650"}}, "parent": {"id": 40018246, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40018246.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40018246"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "If they define components I think they should be added to gazebo experimental because they define the API. For messages that get replaced with `ignition::math` types (Pose, Matrix, Vector, Quaternion, etc), the ones in `ign-msgs` could be reused.", "markup": "markdown", "html": "<p>If they define components I think they should be added to gazebo experimental because they define the API. For messages that get replaced with <code>ignition::math</code> types (Pose, Matrix, Vector, Quaternion, etc), the ones in <code>ign-msgs</code> could be reused.</p>", "type": "rendered"}, "created_on": "2017-07-03T21:08:44.847172+00:00", "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "inline": {}, "updated_on": "2017-07-03T21:08:44.849579+00:00", "type": "pullrequest_comment", "id": 40018650}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"comment": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/40018246.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-40018246"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "is the long term goal to use `ign-msgs` or should we be adding more proto files to gazebo_experimental?", "markup": "markdown", "html": "<p>is the long term goal to use <code>ign-msgs</code> or should we be adding more proto files to gazebo_experimental?</p>", "type": "rendered"}, "created_on": "2017-07-03T20:55:52.007865+00:00", "user": {"display_name": "Ian Chen", "uuid": "{eaa6fca5-6deb-43f6-907f-971c144735dd}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D"}, "html": {"href": "https://bitbucket.org/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5/1e4adcdf-1946-4280-9aea-eb5f15a7f912/128"}}, "nickname": "Ian Chen", "type": "user", "account_id": "557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5"}, "inline": {}, "updated_on": "2017-07-03T20:55:52.010367+00:00", "type": "pullrequest_comment", "id": 40018246}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components defined by protobuf files", "destination": {"commit": {"hash": "e6fb486bfb33", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e6fb486bfb33.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e6fb486bfb33"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "76ecf6853d03", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/76ecf6853d03.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/76ecf6853d03"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-07-03T16:41:55.447520+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components defined by protobuf files", "destination": {"commit": {"hash": "e6fb486bfb33", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e6fb486bfb33.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e6fb486bfb33"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e8518f6852b2", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e8518f6852b2.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e8518f6852b2"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-07-03T16:22:53.835013+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components defined by protobuf files", "destination": {"commit": {"hash": "e6fb486bfb33", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e6fb486bfb33.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e6fb486bfb33"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "03c7a3e9fc42", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/03c7a3e9fc42.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/03c7a3e9fc42"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-30T17:17:10.555180+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components defined by protobuf files", "destination": {"commit": {"hash": "e6fb486bfb33", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e6fb486bfb33.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e6fb486bfb33"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2cef2103b983", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/2cef2103b983.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/2cef2103b983"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-28T20:30:43.375314+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components generated from protobuf", "destination": {"commit": {"hash": "e6fb486bfb33", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e6fb486bfb33.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e6fb486bfb33"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2cef2103b983", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/2cef2103b983.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/2cef2103b983"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-28T20:28:55.230430+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components generated from protobuf", "destination": {"commit": {"hash": "7ba0f5af6491", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/7ba0f5af6491.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/7ba0f5af6491"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "6a5e6329baa4", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/6a5e6329baa4.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/6a5e6329baa4"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-28T17:29:56.184656+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components generated from protobuf", "destination": {"commit": {"hash": "7ba0f5af6491", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/7ba0f5af6491.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/7ba0f5af6491"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "eb1fdab78fa4", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/eb1fdab78fa4.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/eb1fdab78fa4"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-28T17:23:39.119305+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "Depends on pull request #33 being merged, after which this can be retargeted at default. This pull request is only the component generating code. The integration of this is in pull request #37\r\n\r\nThis is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nNotes/Limitations on generation from protobuf files:\r\n\r\n* must have exactly one top-level message per proto file\r\n* can import other proto files as long as they have exactly one top-level message\r\n* can use enumerations as long as they're nested in a message\r\n* Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "6fbd5d84da26", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/6fbd5d84da26.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/6fbd5d84da26"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-22T21:42:48.350303+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "6fbd5d84da26", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/6fbd5d84da26.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/6fbd5d84da26"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-22T20:16:11.213728+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "be2a1299b511", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/be2a1299b511.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/be2a1299b511"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-22T20:12:11.692720+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f9ed58916894", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/f9ed58916894.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/f9ed58916894"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-22T16:21:00.192060+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "94d9c753e1b8", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/94d9c753e1b8.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/94d9c753e1b8"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-22T15:56:28.052721+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/2722483835-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate these files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * This is the only header file that gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.hh`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n* `Pose.factory.cc`\r\n    * Registers plugin of type `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/3425815260-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation isn't allocated in some random place on the heap. The database will use the factory to construct them adjacent in memory. When a user asks for a component on an entity, they get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1607a1472b8b", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/1607a1472b8b.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/1607a1472b8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-20T17:20:24.314267+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1607a1472b8b", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/1607a1472b8b.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/1607a1472b8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-20T15:38:20.450469+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "04fd0a6a249c", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/04fd0a6a249c.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/04fd0a6a249c"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-19T22:58:14.684000+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e86a740988b3", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e86a740988b3.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e86a740988b3"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-19T22:44:37.286685+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "0d882e504b9f", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/0d882e504b9f.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/0d882e504b9f"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-19T20:31:12.485966+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "acd9760458a7", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/acd9760458a7.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/acd9760458a7"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-19T18:53:32.643526+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "334b717dd4f1", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/334b717dd4f1.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/334b717dd4f1"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-19T18:48:15.692289+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e6fa2cbcb421", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e6fa2cbcb421.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e6fa2cbcb421"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-19T15:40:30.762605+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector3d, quaternion, matrix3d, and Pose are replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5ba991b426f1", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/5ba991b426f1.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/5ba991b426f1"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T22:43:01.903746+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5ba991b426f1", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/5ba991b426f1.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/5ba991b426f1"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T22:42:12.776774+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "e855b245955d", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/e855b245955d.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/e855b245955d"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ef4c6b0f0278", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/ef4c6b0f0278.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/ef4c6b0f0278"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T22:03:22.055250+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "9d9d99f90a33", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/9d9d99f90a33.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/9d9d99f90a33"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T21:59:29.186087+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "3f0b4f8acd28", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/3f0b4f8acd28.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/3f0b4f8acd28"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T21:52:13.308278+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nA protobuf compiler plugin generates c++ code for components. A developer will write a protobuf message, invoke a cmake macro to turn it into a component, and use the generated API.\r\n\r\nFor example this protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like this:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n* RTTI no longer needed!\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* A second pull request\r\n    * Replace existing components with with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)\r\n\r\n\r\n## Generated Code ##\r\n\r\n![generated_files.png](https://bitbucket.org/repo/baqryA7/images/3391262902-generated_files.png)\r\n\r\nGiven a protobuf file called `Pose.proto`, the protoc plugin will generate four files:\r\n\r\n* `Pose.api.hh`\r\n    * Has Api class called `Pose` using PIMPL pattern\r\n    * Api class inherits from `gazebo::ecs::ComponentAPI`\r\n    * this is the only file gets installed\r\n* `Pose.api.cc`\r\n    * Definitions for generated API class\r\n* `Pose.storage.hh`\r\n    * Has storage class called `PoseStorage`\r\n* `Pose.factory.cc`\r\n    * Has a factory class with methods for constructing/destructing API and Storage classes\r\n    * This is a plugin, inherits from `gazebo::ecs::ComponentFactory`\r\n\r\n![libgazboComponentXIncludes.png](https://bitbucket.org/repo/baqryA7/images/2069508132-libgazboComponentXIncludes.png)\r\n\r\nThe generated files get built into a single plugin library called `libGazeboComponentPose.so`. Loading this library gives an instance of `ComponentFactory`, which will allow `gazebo::ecs::EntityComponentDatabase` to store the component.\r\n\r\n![database_pimpl.png](https://bitbucket.org/repo/baqryA7/images/1871514051-database_pimpl.png)\r\n\r\n Unlike a normal PIMPL class, the private implementation won't be allocated in some random place on the heap. The database will use the factory methods keep the private implementations adjacent in memory. When a user asks for a component on an entity, they will get an instance of the API class constructed with a reference to storage inside of the database. This layout means fewer cache misses when a system does work with components because the storage for that type of component is tightly packed.", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4f8e7fa73be3", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/4f8e7fa73be3.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/4f8e7fa73be3"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T21:32:59.997855+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use enumerations as long as they're nested in a message\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Get help about installing the CMake macro and protoc plugin so someone could use it\r\n* Document what gets generated, and how to use it\r\n* A second pull request\r\n    * Replace all components with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4f8e7fa73be3", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/4f8e7fa73be3.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/4f8e7fa73be3"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T20:23:27.669171+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Document what gets generated, and how to use it\r\n* A second pull request\r\n    * Replace all components with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nTo-do in the future\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4f8e7fa73be3", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/4f8e7fa73be3.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/4f8e7fa73be3"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T20:19:49.178146+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Document what gets generated, and how to use it\r\n* A second pull request\r\n    * Replace all components with proto files\r\n    * Update all APIs to use this new style of components\r\n\r\nLong term plan\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4f8e7fa73be3", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/4f8e7fa73be3.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/4f8e7fa73be3"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T20:19:24.423811+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4f8e7fa73be3", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/4f8e7fa73be3.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/4f8e7fa73be3"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T20:09:14.590009+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "56a2aff50875", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/56a2aff50875.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/56a2aff50875"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T19:21:48.982194+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "53bffef400cd", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/53bffef400cd.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/53bffef400cd"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T19:10:34.827642+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "69e4762d20cc", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/69e4762d20cc.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/69e4762d20cc"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T15:31:11.988584+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "af6ec618bee2", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/af6ec618bee2.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/af6ec618bee2"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T02:11:59.138069+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "aaea34be72c6", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/aaea34be72c6.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/aaea34be72c6"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T00:36:42.544728+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "db7433504c79", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/db7433504c79.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/db7433504c79"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T00:25:28.346956+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ec47f04b3576", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/ec47f04b3576.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/ec47f04b3576"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-16T00:11:35.609076+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files!\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * can use **oneof**\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Lots more testing\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b1e5d584f64f", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b1e5d584f64f.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b1e5d584f64f"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-15T23:43:35.865218+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b1e5d584f64f", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b1e5d584f64f.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b1e5d584f64f"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-15T23:39:06.781786+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "76c2329545b2", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/76c2329545b2.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/76c2329545b2"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-14T23:28:32.012117+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}, {"update": {"description": "This is a work in progress redesign of components. The goal for this pull request is to offer these benefits\r\n\r\n* No use of RTTI #29\r\n* Components use PIMPL #25\r\n\r\nWithout losing these benefits:\r\n\r\n* New components come from plugins without recompiling the database\r\n* Component data can be stored adjacent in memory\r\n* Components have convenient `ignition::math` types\r\n\r\nAnd with a path towards these features in the future:\r\n\r\n* Components are serializable\r\n    * Create a component viewer #19\r\n    * Run ECS on different systems #18 \r\n\r\nIt uses a plugin to the protobuf compiler to generate c++ code for components. The vision is a developer writes a protobuf message, invokes a cmake macro to turn it into a component, and begins using the generated API.\r\n\r\nFor example This protobuf message\r\n\r\n```\r\nsyntax = \"proto2\";\r\n\r\npackage gazebo.components;\r\n\r\nimport \"gazebo/components/Pose3d.proto\";\r\n\r\nmessage MyPoseComponent\r\n{\r\n  optional string ParentFrame = 1;\r\n  optional Pose3d Pose = 3;\r\n}\r\n```\r\n\r\nWould be used like so:\r\n```\r\n// Component API files end in \".api.hh\"\r\n#include \"gazebo/components/MyPoseComponent.api.hh\"\r\n// ...\r\n// No RTTI being used here, MyPoseComponent has a class-wide id given to it by the database\r\ngazebo::components::MyPoseComponent comp;\r\nsomeEntity.Component(comp);\r\n\r\n// .gazebo.components.Pose3d swapped for igntion::math::Pose3d type\r\ncomp.Pose().Pos().X() = 5;\r\ncomp.Pose().Rot().W() = 1.0f;\r\n\r\n// ParentFrame string became a method that returns a reference\r\ncomp.ParentFrame() = \"my_frame\";\r\nstd::cout << comp.ParentFrame(); // \"my_frame\"\r\n```\r\n\r\n\r\nWhat currently works:\r\n\r\n* Generate code from protobuf files\r\n    * must have exactly one top-level message per proto file\r\n    * can use any of the simple types (int32, string, float64, etc)\r\n    * Can use **repeated** types\r\n    * can import other proto files as long as they have exactly one top-level message\r\n    * can use nested enumerations\r\n    * can use nested messages\r\n    * can specify default values\r\n    * Vector, quaternion, and Pose is replaced with ignition::math types in API\r\n* Generate component plugin with a CMake macro\r\n    * The plugin is a `ComponentFactory` that tells database how to store/create the API\r\n* Component API is a PIMPL class\r\n\r\nTo-do\r\n\r\n* Support protobuf **oneof** and turn them into C++ unions\r\n* Replace all components with proto files\r\n* style/cleanup in protoc plugin\r\n* Update all APIs to use this new style of components\r\n* Document the design on this PR\r\n* Document how to use the code generated from the protobuf message\r\n\r\n\r\nLong term (not this pull request)\r\n\r\n* Make components serializable (Shouldn't be too hard, they're defined as protobuf messages)\r\n* Do the cool things that need serializable components (Multiple PCs powering one simulation, component viewer, etc)", "title": "[WIP] Components generated from protobuf", "destination": {"commit": {"hash": "b45f33d1377a", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/b45f33d1377a.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/b45f33d1377a"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "21e4bdd778fe", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/commit/21e4bdd778fe.json"}, "html": {"href": "#!/osrf/gazebo_experimental/commits/21e4bdd778fe"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "branch": {"name": "components_pimpl"}}, "state": "OPEN", "author": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "date": "2017-06-13T17:44:33.333902+00:00"}, "pull_request": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}}], "next": "data/repositories/osrf/gazebo_experimental/pullrequests/36/activity_ctx=GAAHngfLuA.json"}