{"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/41111820.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-41111820"}}, "parent": {"id": 41018798, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36/comments/41018798.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36/_/diff#comment-41018798"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 36, "links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/pullrequests/36.json"}, "html": {"href": "#!/osrf/gazebo_experimental/pull-requests/36"}}, "title": "Components defined by protobuf files"}, "content": {"raw": "This looks like a much larger problem. **TL;DR this will take a couple days to fix**\n\nI meant for component libraries to be self contained (as in the `DefaultValues` in the `NestedMessage` is distinct from `DefaultValues`). When `NestedMessage` is generated, the protobuf compiler also generates code for all protobuf files it imports.  This is what allows `NestedMessage.storage.hh` to include `DefaultValues.storage.hh` even though it's not installed. The source of the issue is the `NestedMessage` library doesn't have the implementations of the `DefaultValue` APIs. The tests just happen to pass on xenial because all of the tests are in the same executable.\n\n**These paragraphs explore solutions I don't think we should do**\n\nOne almost-solution is to make `NestedMessage.api.cc` include `DefaultValues.api.cc` so the `NestedMessage` library has the API definitions. This would work for a while. The problems will begin when someone creates a component in another repo (call it `Flyable`) that depends on a component in this repo (say `Pose`), and then later `Pose` changes.\n\n The `Flyable` storage has a field of type `Pose` storage. If `Pose` later gets an additional field, the field in the `Flyable` storage hasn't changed. When both the updated `Pose` and old `Flyable` are loaded in the same process, there will be duplicate symbols for the API definitions of `Pose`. Depending on which definitions are picked by the loader, there may be segfaults either when accessing a `Pose` component, or when accessing a `Flyable` component.\n\nA complete solution to the almost-solution is to change the names of the symbols of the `Pose` API definitions inside of the `Flyable` library. This can be done in a few ways. The first way is to wrap the imports of `Pose.api.hh`, `Pose.api.cc`, and `Pose.storage.hh` in a namespace. This isn't ideal because it means standard libraries included in `Pose.api.hh` will also get included in that namespace if they haven't been included elsewhere first, which can cause linker and compiler errors in some situations. The second way is the same as the first, but with generated headers split into two parts: one part includes standard libraries and the other part is the generated code. Only the generated code part would be included inside a namespace so as to not accidentally push `std` stuff into a namespace. The third way is to use preprocessor macros to insert namespaces into the header files only when included by other components.\n\n** Right option here **\n\nI think the right option is to ditch the philosophy of making the component self contained and make `Flyable` depend on `Pose`. `Flyable` becomes immune to `Pose` changes and there's no duplicate symbol issues.The downside is it's harder to code. The `Flyable` storage would have to use the `Pose` component factory instead of the `Pose` storage class. The `Flyable` factory would have to use the `Pose` factory to determine the total size of a `Flyable` component, and to construct/destruct/deep copy/shallow copy a `Pose` storage which is adjacent to the `Flyable` storage. The `Flyable` API definition responsible for returning a `Pose` API instance would have to use the `Flyable` factory to determine the address of the constructed `Pose` storage. There are a bunch of details, but it's doable.", "markup": "markdown", "html": "<p>This looks like a much larger problem. <strong>TL;DR this will take a couple days to fix</strong></p>\n<p>I meant for component libraries to be self contained (as in the <code>DefaultValues</code> in the <code>NestedMessage</code> is distinct from <code>DefaultValues</code>). When <code>NestedMessage</code> is generated, the protobuf compiler also generates code for all protobuf files it imports.  This is what allows <code>NestedMessage.storage.hh</code> to include <code>DefaultValues.storage.hh</code> even though it's not installed. The source of the issue is the <code>NestedMessage</code> library doesn't have the implementations of the <code>DefaultValue</code> APIs. The tests just happen to pass on xenial because all of the tests are in the same executable.</p>\n<p><strong>These paragraphs explore solutions I don't think we should do</strong></p>\n<p>One almost-solution is to make <code>NestedMessage.api.cc</code> include <code>DefaultValues.api.cc</code> so the <code>NestedMessage</code> library has the API definitions. This would work for a while. The problems will begin when someone creates a component in another repo (call it <code>Flyable</code>) that depends on a component in this repo (say <code>Pose</code>), and then later <code>Pose</code> changes.</p>\n<p>The <code>Flyable</code> storage has a field of type <code>Pose</code> storage. If <code>Pose</code> later gets an additional field, the field in the <code>Flyable</code> storage hasn't changed. When both the updated <code>Pose</code> and old <code>Flyable</code> are loaded in the same process, there will be duplicate symbols for the API definitions of <code>Pose</code>. Depending on which definitions are picked by the loader, there may be segfaults either when accessing a <code>Pose</code> component, or when accessing a <code>Flyable</code> component.</p>\n<p>A complete solution to the almost-solution is to change the names of the symbols of the <code>Pose</code> API definitions inside of the <code>Flyable</code> library. This can be done in a few ways. The first way is to wrap the imports of <code>Pose.api.hh</code>, <code>Pose.api.cc</code>, and <code>Pose.storage.hh</code> in a namespace. This isn't ideal because it means standard libraries included in <code>Pose.api.hh</code> will also get included in that namespace if they haven't been included elsewhere first, which can cause linker and compiler errors in some situations. The second way is the same as the first, but with generated headers split into two parts: one part includes standard libraries and the other part is the generated code. Only the generated code part would be included inside a namespace so as to not accidentally push <code>std</code> stuff into a namespace. The third way is to use preprocessor macros to insert namespaces into the header files only when included by other components.</p>\n<p><strong> Right option here </strong></p>\n<p>I think the right option is to ditch the philosophy of making the component self contained and make <code>Flyable</code> depend on <code>Pose</code>. <code>Flyable</code> becomes immune to <code>Pose</code> changes and there's no duplicate symbol issues.The downside is it's harder to code. The <code>Flyable</code> storage would have to use the <code>Pose</code> component factory instead of the <code>Pose</code> storage class. The <code>Flyable</code> factory would have to use the <code>Pose</code> factory to determine the total size of a <code>Flyable</code> component, and to construct/destruct/deep copy/shallow copy a <code>Pose</code> storage which is adjacent to the <code>Flyable</code> storage. The <code>Flyable</code> API definition responsible for returning a <code>Pose</code> API instance would have to use the <code>Flyable</code> factory to determine the address of the constructed <code>Pose</code> storage. There are a bunch of details, but it's doable.</p>", "type": "rendered"}, "created_on": "2017-07-19T22:21:53.271790+00:00", "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "updated_on": "2017-07-19T22:21:53.274513+00:00", "type": "pullrequest_comment", "id": 41111820}