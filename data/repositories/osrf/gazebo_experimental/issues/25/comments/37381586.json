{"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/issues/25/comments/37381586.json"}, "html": {"href": "#!/osrf/gazebo_experimental/issues/25#comment-37381586"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental/issues/25.json"}}, "type": "issue", "id": 25, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "title": "Components should use PIMPL pattern to avoid ABI breakage during updates"}, "content": {"raw": "Related to #17, #18, and #19: I looked at seeing if c++ code generated by protobuf would maintian ABI compatibility if fields are added, they're not. Fields are added to the classes as private member variables, so adding one will change the size of the class. This rules out using a generated protobuf class as the API used by systems for reading/writing components.\n\nIf the data was serialized and then passed to the systems adding fields is ABI compatible. Systems would have their own compiled version of the generated protobuf class which has support for forwards/backwards compatibility within some limits. A downside is it adds the overhead of serializing/deserializing instead of just reading from the component.", "markup": "markdown", "html": "<p>Related to #17, #18, and <a href=\"#!/osrf/gazebo_experimental/issues/19/create-viewer-for-viewing-all-entities-and\" rel=\"nofollow\" title=\"Create viewer for viewing all entities and components\" class=\"ap-connect-link\">#19</a>: I looked at seeing if c++ code generated by protobuf would maintian ABI compatibility if fields are added, they're not. Fields are added to the classes as private member variables, so adding one will change the size of the class. This rules out using a generated protobuf class as the API used by systems for reading/writing components.</p>\n<p>If the data was serialized and then passed to the systems adding fields is ABI compatible. Systems would have their own compiled version of the generated protobuf class which has support for forwards/backwards compatibility within some limits. A downside is it adds the overhead of serializing/deserializing instead of just reading from the component.</p>", "type": "rendered"}, "created_on": "2017-06-05T15:59:40.720836+00:00", "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "updated_on": "2017-06-05T15:59:56.630653+00:00", "type": "issue_comment", "id": 37381586}