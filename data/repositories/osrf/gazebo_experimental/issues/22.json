{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo_experimental.json"}, "html": {"href": "#!/osrf/gazebo_experimental"}, "avatar": {"href": "data/bytebucket.org/ravatar/{bc79acda-fe93-46b4-96a4-f1603142a10a}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo_experimental", "full_name": "osrf/gazebo_experimental", "uuid": "{bc79acda-fe93-46b4-96a4-f1603142a10a}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo_experimental/issues/22/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo_experimental/issues/22.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/issues/22/watch"}, "comments": {"href": "data/repositories/osrf/gazebo_experimental/issues/22/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo_experimental/issues/22/entitycomponentdatabase-method-of-making"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo_experimental/issues/22/vote"}}, "reporter": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "title": "EntityComponentDatabase method of making components immutable is flawed", "component": null, "votes": 0, "watches": 1, "content": {"raw": "Systems are given an immutable state (entities, components). Any changes an ECS system makes are copied and applied later. The manor in which the ECS core code makes sure components are immutable is flawed if the component contains a pointer. The problem is due to the copier stored with the component type.\r\n\r\nStep 1 and 2 happen while the ECS systems are updating. Step 3 happens after all ECS systems have updated.\r\n\r\n![system_modifies_component.png](data/bitbucket.org/repo/baqryA7/images/3140240510-system_modifies_component.png)\r\n\r\nThe problem is ComponentTypeInfo.copier() does a shallow copy. Consider a component with an `std::string name` in it. One ECS system changes the name. In the same update another ECS system reads the name. The name read by the second ECS system depends on whether it happens before or after the first system modified it. This makes the simulation less deterministic, and could potentially crash if both systems ran at the same time.\r\n\r\nOne solution is to have `ComponentTypeInfo.copier()` store the component's copy constructor. It would be up to the author of the component to make sure the copy constructor does a deep copy. Currently the database does not call the destructor on the modified storage in step 3, but it would need to do so with this change.", "markup": "markdown", "html": "<p>Systems are given an immutable state (entities, components). Any changes an ECS system makes are copied and applied later. The manor in which the ECS core code makes sure components are immutable is flawed if the component contains a pointer. The problem is due to the copier stored with the component type.</p>\n<p>Step 1 and 2 happen while the ECS systems are updating. Step 3 happens after all ECS systems have updated.</p>\n<p><img alt=\"system_modifies_component.png\" src=\"data/bitbucket.org/repo/baqryA7/images/3140240510-system_modifies_component.png\" /></p>\n<p>The problem is ComponentTypeInfo.copier() does a shallow copy. Consider a component with an <code>std::string name</code> in it. One ECS system changes the name. In the same update another ECS system reads the name. The name read by the second ECS system depends on whether it happens before or after the first system modified it. This makes the simulation less deterministic, and could potentially crash if both systems ran at the same time.</p>\n<p>One solution is to have <code>ComponentTypeInfo.copier()</code> store the component's copy constructor. It would be up to the author of the component to make sure the copy constructor does a deep copy. Currently the database does not call the destructor on the modified storage in step 3, but it would need to do so with this change.</p>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2017-05-09T17:19:52.085938+00:00", "milestone": null, "updated_on": "2017-05-18T16:19:28.440627+00:00", "type": "issue", "id": 22}